---
title: "JMJPFU-DagSentiment-Experimentation"
output: html_notebook
---

# JMJPFU
### 14-May-2017

This is the notebook for doing experiments

```{r}
library(rvest)
library(dplyr)
library(tm)
library(ngram)
library(stringr)
library(wordcloud)
```

### Importing data set

```{r}
hotText <- Hotel_reviews[1,1]

paste(hotText)
```

### Step 1 : Let us now create some aspect Dictionaries

```{r}
## Aspect Dictionary: Food

foodDict <- list()

foodDict <- append(foodDict,"food")
foodDict <- append(foodDict,c("dishes","icecream","fish"))

foodDict <- unlist(foodDict)

foodDict <- c(foodDict,"chicken")

########## Aspect Dictionary : Ambience

ambDict <- c("ambience","atmosphere")

########## Aspect Dictionary : Service

serDict <- c("service","waiter")

########## Aspect Pricing :

pricDict <- c("price","pricing","cost","expense")

```
,


### Creating sentiment dictionaries

```{r}
# Creating a positive dictionary
postDic <- c("consistent","good","fun","fast","consistently","interesting","authentic","wonderful","tasty")

# Creating a negative dictionary

negDic <- c("bad","nonsense","exorbitant")

# Creating a polarity changing dictionary

polDic <- c("no","not","never")


```






### Step 1 : Splitting as per different lines

```{r}

# Doing the split sentence by sentence

textSplit <- str_split(hotText,"[.]")

# Unlisting the split so that it is a list of sentences

textSplit <- unlist(textSplit)

# Finding the sentence length

sentLength <- length(textSplit)

# Looping over the list of sentences

for(i in 1: sentLength){
  
  textSamp <- textSplit[i]
  
  # Let us clean up the text
  
  textSamp <- cleansamp(textSamp)
  
  # Converting to a corpus
  
  textCorp <- Corpus(VectorSource(textSamp))
  
  # Let us remove the stop words
  
  textCorp <- tm_map(textCorp,removeWords,c("the","was","i","at","a","when","is","and","has","for","of","are","to","an","it","in","be","if","on","since","as","had","so","he","him","me","her","she","its","that","its","been","he","there"))
  
  textCorp <- tm_map(textCorp,stripWhitespace)
  
 # Getting back the clean text
  
  textClean <- textCorp[[1]]$content
  
  textClean <- stripWhitespace(textClean)
  
 # Split the text again based on the spaces 
  
  cleantxtSplit <- str_split(textClean," ")
  
  # Unlisting the text again
  
  cleantxtSplit <- unlist(cleantxtSplit)
  
  ############################### DAG Extraction Layer ######################
  
  # Creating a data frame to store the polarity scores
  
  polFeatDf <- data.frame(matrix(nrow=0,ncol=12))
  
  names(polFeatDf) <- c("food_pol","food_pos","food_neg","amb_pol","amb_pos","amb_neg","ser_pol","ser_pos","ser_neg","pri_pol","pri_pos","pri_neg")
  
  # Getting polarity of each aspect
  
  polFeatDf[1,1] <- recScanner(cleantxtSplit,"food")$dagStore 
  polFeatDf[1,2] <- recScanner(cleantxtSplit,"food")$PCount/length(cleantxtSplit)
  polFeatDf[1,3] <- recScanner(cleantxtSplit,"food")$Ncount/length(cleantxtSplit)
  
  polFeatDf[1,4] <- recScanner(cleantxtSplit,"ambience")$dagStore
  polFeatDf[1,5] <- recScanner(cleantxtSplit,"ambience")$PCount/length(cleantxtSplit)
  polFeatDf[1,6] <- recScanner(cleantxtSplit,"ambience")$Ncount/length(cleantxtSplit)
  
  polFeatDf[1,7] <- recScanner(cleantxtSplit,"service")$dagStore
  polFeatDf[1,8] <- recScanner(cleantxtSplit,"service")$PCount/length(cleantxtSplit)
  polFeatDf[1,9] <- recScanner(cleantxtSplit,"service")$Ncount/length(cleantxtSplit)
  
  polFeatDf[1,10] <- recScanner(cleantxtSplit,"price")$dagStore
  polFeatDf[1,11] <- recScanner(cleantxtSplit,"price")$PCount/length(cleantxtSplit)
  polFeatDf[1,12] <- recScanner(cleantxtSplit,"price")$Ncount/length(cleantxtSplit)
  
} # End of the first for loop

# Combining the sentence polarity to a consolidating data frame

combPolDf <- data.frame(matrix(nrow=0,ncol=12))
names(combPolDf) <- c("food_pol","food_pos","food_neg","amb_pol","amb_pos","amb_neg","ser_pol","ser_pos","ser_neg","pri_pol","pri_pos","pri_neg")


combPolDf <- rbind(combPolDf,polFeatDf)


```
# JMJPFU
### 15-May-2017

1. Created a function for the aspect - sentiment search and the DAG updater

# JMJPFU
### 18-May-2017

1. Created a polarity changing words like (no, not, never). Applying before any negative or positive words changes its polarity
2. Created a counter of polarity words

# JMJPFU
### 20-May-2017

1.Negative words were worked out and the counts were corrected
2. Create DAG updater for all sentiments : Dag updater data frame was created and updated. However need to work on a graph formulae with metadata attached.

```{r}
# Created some more examples along with the text

cleantxtSplit <- c(cleantxtSplit,"chicken","wonderful","tasty")
```



```{r}

recScanner <- function(cleantxtSplit,aspect){
  
  # CleantxtSplit : This is the text which needs to be recursively scanned
  # aspect : This is a charachter which is checked to find out the right aspect
  # foodDict : This is the dictionary if the aspect is food
  ### Body of the function ###
  
  dagLen <- length(cleantxtSplit) # Find the length of the text to be recursively scanned
  
  # Checking if there are any intersecting items from respective aspect Dictionary
  
  ## change : foodMatch => aspectMatch
  
  # Doing a intersect to find the matching words in the passed text with the dictionary
  
  if(aspect == "food"){aspectMatch <- intersect(cleantxtSplit,foodDict)  
  
  
  }else if(aspect == "ambience" ){aspectMatch <- intersect(cleantxtSplit,ambDict)}else if(aspect == "service"){aspectMatch <- intersect(cleantxtSplit,serDict) }else if(aspect == "price"){aspectMatch <- intersect(cleantxtSplit,pricDict)}
    
  # Find the index of the matching text
  
  if(length(aspectMatch) > 0){  
    
    # Find the index of the aspect in the original text.The result of the below is a list of index for matching           words in the dictionary. If the match is found the index is listed there. Else we get only NA's 
    
    matchId <- match(aspectMatch,cleantxtSplit)
    
    # The below code is to get only the Non NA id's
    
    matchId <- matchId[!is.na(matchId)] 
  
    ########## Next start the recursive checking for sentiment from the sentiment dictionary #####
    
    if(length(matchId) > 0){ 
      
      # Find the total number of indexes where the dictionary is matching
      
      indLen <- length(matchId)
      
      # Start a for loop to recursively start another scanning of text from the index of matching aspect in the text
      
      # Start a empty data frame to store the DAGs for each index
      
       dagStore <- list() # Experimenting by brining this dag to line 243
      
      for(j in 1:indLen){
        
        #dagStore <- list()
        
        # Getting the first index and Incrementing the index number so that it starts comparing with the next word            onward
        
        tempInd <- matchId[j] + 1
        
        # Initializing a neutral polarity as default to the Dag polarity tagger. In addition initializing positive          counter and also negative counter
        
        recDag <- "N" 
        Pcou <- 0
        Ncou <- 0
        negCol <- c() # Negative terms consolidator
        posCol <- c() # positive terms consolidator
        comCol <- c() # Competitor terms consolidator
        polCol <- c() # polarity changer consolidator
        pcpolCol <- c() # polarity changing positive words consolidator
        pcnegCol <- c() # polarity changing negative words consolidator
        
        # Now starting a while index so that the index recursively passess through the DAG
        
        while(tempInd <= dagLen){
          ## Defining the empty stores
          entity <- c() # Only one ID equivalent to aspect
          polarity <- c() # Can have multiple polarities
          positive <- c() # Ids of the positive words used in dictionary
          negative <- c() # Ids of the negative words used in dictionary
          competitor <- c() # Ids referring to competitor
          polChanger <- c() # Polarity changing words
          pcPos <- c() # Polarity changed positive
          pcNeg <- c() # Polarity changed negative
          
          
          # Finding the polarity recursively for the relevant word in the text
          
          if(length(intersect(cleantxtSplit[tempInd],postDic)) > 0){
            recPost <- "P"
          }else if(length(intersect(cleantxtSplit[tempInd],negDic)) > 0){
            recPost <- "Ne" 
          }else if(length(intersect(cleantxtSplit[tempInd],polDic)) > 0){
            recPost <- "Pc"
          }else{recPost <- "N"}
  
          # Based on the polarity of the word the DAG is updated for polarity
        
        if(recPost == "P" & recDag == "N"){
          recDag <- "P"
          Pcou <- Pcou + 1 # incrementing the counter by one
          tempPos <- match(intersect(cleantxtSplit[tempInd],postDic),postDic ) # Adding the index of positive in a            temporary container
          positive <- c(positive,tempPos) # collecting the positive counts 
          
        }else if(recPost == "Ne" & recDag == "N"){
          
          recDag <- "Ne"
          Ncou <- Ncou + 1
          tempNeg <- match(intersect(cleantxtSplit[tempInd],negDic),negDic ) # Adding index of Negative words
          negative <- c(negative,tempNeg) # Collecting negative words
          
          
        }else if(recPost == "N" & recDag == "N"){
          recDag <- "N"
          
        }else if(recPost == "P" & recDag == "P"){
            recDag <- "P"
            Pcou <- Pcou + 1
            tempPos <- match(intersect(cleantxtSplit[tempInd],postDic),postDic ) # Adding the index of positive in a             temporary container
            positive <- c(positive,tempPos) # collecting the positive counts 
            
        }else if(recPost == "Ne" & recDag == "P" ){
          recDag == "Ne"
          Ncou <- Ncou + 1
          tempNeg <- match(intersect(cleantxtSplit[tempInd],negDic),negDic ) # Adding index of Negative words
          negative <- c(negative,tempNeg) # Collecting negative words
          
        }else if(recPost == "N" & recDag == "P"){
          
          recDag <- "P" # No counter update for positive as the counter was already update earlier
          
        }else if(recPost == "P" & recDag == "Pc"){
          
          recDag <- "Ne"
          Ncou <- Ncou + 1
          tempPos <- match(intersect(cleantxtSplit[tempInd],postDic),postDic ) # Adding the index of positive in a             temporary container
          pcPos <- c(pcPos,tempPos) # collecting the polarity changed positive counts 
          
        }else if(recPost == "Ne" & recDag == "Pc"){
          
          recDag <- "P"
          Pcou <- Pcou + 1
          tempNeg <- match(intersect(cleantxtSplit[tempInd],negDic),negDic ) # Adding index of Negative words
          pcNeg <- c(pcNeg,tempNeg) # Collecting polarity changed negative words
          
        }else if(recPost == "N" & recDag == "Pc"){recDag <- "N"}else if(recPost == "Pc"){
          
          recDag <- "Pc"
          tempPc <- match(intersect(cleantxtSplit[tempInd],polDic),polDic )
          polChanger <- c(polChanger,tempPc) # collecting ids of polarity changed words
          
        }else{
          recDag == "Ne"
          tempNeg <- match(intersect(cleantxtSplit[tempInd],negDic),negDic ) # Adding index of Negative words
          negative <- c(negative,tempNeg) # Collecting negative words
          
        }
          
          # Incrementing the tempInd inside the loop
          
          tempInd <- tempInd + 1 
          
          # Checking if we have reached any other aspect. This section needs to be updated based on the new aspects             which will get introduced
        if(aspect == "food"){
          
          asCheck <- length(intersect(cleantxtSplit[tempInd],ambDict))
          if(asCheck > 0){
            
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],foodDict),foodDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],foodDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],serDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],foodDict),foodDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],foodDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],pricDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],foodDict),foodDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],foodDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            
            break
            # If a next index is found come out of the while loop
          }
          #entityId <- match(intersect(cleantxtSplit[matchId[j]],foodDict),foodDict)
          entityId <- intersect(cleantxtSplit[matchId[j]],foodDict)
          entity <- c(entity,entityId)
          posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg) 
          
        }else if(aspect == "ambience"){
          
          asCheck <- length(intersect(cleantxtSplit[tempInd],foodDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],ambDict),ambDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],ambDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
            
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],serDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],ambDict),ambDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],ambDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],pricDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],ambDict),ambDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],ambDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          } # If a next index is found come out of the while loop
          
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],ambDict),ambDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],ambDict)
            entity <- c(entity,entityId)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg) 
          
        }else if(aspect == "service"){
          
          asCheck <- length(intersect(cleantxtSplit[tempInd],foodDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],serDict),serDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],serDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
            
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],ambDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],serDict),serDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],serDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],pricDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],serDict),serDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],serDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],serDict),serDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],serDict)
            entity <- c(entity,entityId)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg) 
            
            
        }else if(aspect == "price"){
          
          asCheck <- length(intersect(cleantxtSplit[tempInd],foodDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],pricDict),pricDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],pricDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],ambDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],pricDict),pricDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],pricDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
          asCheck <- length(intersect(cleantxtSplit[tempInd],serDict))
          if(asCheck > 0){
            # Storing the value of the entity
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],pricDict),pricDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],pricDict)
            entity <- c(entity,entityId)
            # Storing the value of the polarity
            
            polarity <- c(polarity,recDag)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            # Joining together all the metadata
            entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
            
            #dagStore[[length(dagStore)+1]] <- entList
            
            break
          }
            #entityId <- match(intersect(cleantxtSplit[matchId[j]],pricDict),pricDict)
            entityId <- intersect(cleantxtSplit[matchId[j]],pricDict)
            entity <- c(entity,entityId)
            posCol <- c(posCol,positive)
            negCol <- c(negCol,negative)
            comCol <- c(comCol,competitor)
            polCol <- c(polCol,polChanger)
            pcpolCol <- c(pcpolCol,pcPos)
            pcnegCol <- c(pcnegCol,pcNeg)
            
            
        } # End of the Price check loop
          
          
        
        entList <- list(ent = entity,pola = polarity,pos = posCol,neg = negCol,comp = comCol,polc =     polCol,pcpos = pcpolCol,pcneg = pcnegCol)
          
            } # End of the while loop
        
        # Storing the final dag in the dag storer
        
        
        dagStore[[length(dagStore)+1]] <- entList
        
        
      } # End of Inner for loop looping over the length of indexes
      
    
    
    } # End of the second if Loop for looping over the matching index
    
    list(dagStore = dagStore,PCount = Pcou,Ncount = Ncou)
    
    }else{
      
      dagStore
     
      list(dagStore = dagStore,PCount = 0,Ncount = 0) 
      
    } # End of the first if loop for aspectMatch
        
    
  
  
} # End of the function




```
# JMJPFU
### 21-May-2017

```{r}
# Defining the first level
Food <- list()
# Defining the second hierarchy

Food[['entity']] <- list()

Food[['NeutralCount']] <- list()

Food[['PositiveIds']] <- list()

Food[['NegativeIds']] <- list()

Food[['Polarity']] <- list()

# Loading data into the lists

Food$entity <- c("chicken")

## Methods to append to an existing list hierarchy

Food$entity <- c(Food$entity,"Omlette")

Food$entity <- append(Food$entity,"Leamon")

### Trying to get a third hierarchy

Food$entity$sentiments <- c(1,2,3)

Food$entity <- append(Food$entity,"Boneless Wings")



```

Trying out adding two lists together

```{r}
Temp <- Food

Temp <- append(Temp,Food)

## Checking adding new items to list

Temp$NeutralCount <- c(1,4,5)

## Trying another 
```

# JMJPFU
### 23-May-2017

Method for list coersing

```{r}
myList <- list()

myList[[length(myList) + 1]] <- Food
```

```{r}
testList <- recScanner(cleantxtSplit,"food")$dagStore 


```

# JMJPFU
### 25-May-2017

1. The Dag function was reworked. Most of the wrongs were corrected. however it is getting one more additional list. This needs to be corrected

```{r}
aspect = "food"
#aspect = "service"
#aspect = "price"
#aspect = "ambience"

cleantxtSplit

testList <- recScanner(cleantxtSplit,aspect)$dagStore 

length(testList)



recScanner(cleantxtSplit,aspect)$dagStore 
```

# JMJPFU
### 10-June-2017
1. Some more corrections. All the aspects have an additional line included. Most probably because of the one after the while loop
2. Negative and polarity changers are not been listed properly.

# JMJPFU
### 11-June-2017

1. Try experimenting by moving dag listing in line number 243 - Not required
2. The experiment with removing the daglist inside the ascheck worked
3. However the entity name needs to be looked at in the final output - Changed into actual entity rather than the index

Let us test with more text

```{r}
i = 2
textSamp <- textSplit[i]

cleantxtSplit <- revClean(textSamp)
cleantxtSplit

aspect = "food"
#aspect = "service"
#aspect = "price"
#aspect = "ambience"

testList <- recScanner(cleantxtSplit,aspect)$dagStore 

length(testList)

recScanner(cleantxtSplit,aspect)$dagStore 



```
```{r}
postDic
```

